# -*- coding: utf-8 -*-
"""Workshop2_ANN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jveoUmp-82wh7_j8sSBMaLn0C-xSd8A8
"""

# Install dependencies
!pip install torch gradio

import torch
import torch.nn as nn
import torch.optim as optim
import gradio as gr

# --- Simple ANN with Editable Parameters ---
class FlexibleANN(nn.Module):
    def __init__(self, input_size=4, hidden_size=8, output_size=2, activation_fn=nn.ReLU()):
        super(FlexibleANN, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.activation = activation_fn
        self.fc2 = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        x = self.activation(self.fc1(x))
        x = self.fc2(x)
        return x

"""**STUDENT: Change these parameters**"""

INPUT_SIZE = 4
HIDDEN_SIZE = 16  # Try 8, 16, 32
OUTPUT_SIZE = 2
ACTIVATION_FN = nn.Tanh()  # Try nn.ReLU(), nn.Sigmoid(), nn.Tanh()

# Model
model = FlexibleANN(INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE, ACTIVATION_FN)

# Dummy dataset (or let students upload their own later)
X = torch.randn(500, INPUT_SIZE)
y = torch.randint(0, OUTPUT_SIZE, (500,))

# Training
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)

for epoch in range(100):
    optimizer.zero_grad()
    outputs = model(X)
    loss = criterion(outputs, y)
    loss.backward()
    optimizer.step()

print("âœ… Model Trained Successfully!")

# Gradio Interface
def predict(f1, f2, f3, f4):
    inputs = torch.tensor([[f1, f2, f3, f4]], dtype=torch.float32)
    output = model(inputs)
    _, predicted = torch.max(output.data, 1)
    return f"Predicted Class: {predicted.item()}"

demo = gr.Interface(
    fn=predict,
    inputs=["number", "number", "number", "number"],
    outputs="text",
    title="Build Your Own ANN Classifier!"
)

demo.launch()